# 定点数

## 数据表示

- 数据

  **数据**——是计算机处理的对象

  从用户的角度来看，计算机可以处理数值、文字、图像、声音、视频，甚至各种模拟量。这些形式的信息，在计算机系统内部可以表示成各种各样的数据类型，有文件、图、表、树、阵列、链表、堆栈、向量、串、实数、整数、布尔数、字符等

- 数据表示

  **数据表示**——研究的是计算机硬件能够直接识别、可以被指令系统直接调用的那些**基本数据类型**。

  数据表示采用数据类型中最常用、也是相对比较简单、用硬件实现相对比较容易的几种，比如定点数（整数）、逻辑数（布尔数）、浮点数（实数）、十进制数、字符、字符串、堆栈和向量等

  **复杂的数据类型**是由基本数据类型按照某种结构描述方式在软件中实现的，是数据结构研究的问题。

- 数据编码

  在计算机内部，各种数据（也称信息）都必须经过数字化编码后才能被传送、存储和处理 。要使计算机能处理各种各样的信息，则必须对这些信息进行编码。

  **编码**——就是采用少量的基本符号，选用一定的组合原则，以表示大量复杂多样的信息。

  计算机处理的信息可分为两大类：

  1. 数值信息 ：按进位计算制表示的有大小、正负之分的数学数值；
  2. 非数值信息 ：如文字、图像、语言等

- 数值数据的编码

  + 机器数

    各种数值数据在计算机中表示的形式称为**机器数** ，其特点是采用二进制记数制，数的符号用0 、1 表示，小数点则隐含表示而不占位置

  + 真值

    机器数对应的实际数值称为**数的真值** 

  + 定点数

    小数点位置固定的数称为**定点数**

    计算机中的定点数只采用纯整数或者纯小数形式

  + 浮点数

    小数点位置不固定的数称为**浮点数**

  + 无符号数

    无符号数表示正数，在机器数中没有符号位。对于无符号数，若约定小数点的位置在机器数的最低位之后，则是**纯整数**；若约定小数点的位置在机器数的最高位之前，则是**纯小数**。

  + 有符号数

## 数据的定点表示

- 定点数

  定点数是指小数点位置固定不变的数，小数点的位置通常只有两种约定，相应地有两种类型的定点数，即定点整数和定点小数

  ![image-20210422161511227](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121203.png)

  使用**定点表示法**（比如 2 的补码）能表示以 0 为中心的一定范围的正和负的整数和小数

### 原码

- 简介

  原码（True form）是最容易理解的一种数据编码表示，也称**符号-数值**表示法，即原码表示的机器数由符号位后面直接跟真值的数值构成。
  数值 X 的原码记为 $[X]原$ ，如果机器字长为 n （即采用 n 个二进制位表示数据），则最高位是符号位，0 表示正号，1 表示负号 ，其余的 n–1 位表示数值的绝对值。

  原码又称作**带符号的绝对值表示**

- 定点小数的原码
  $$
  [X]原 = 
  \left\{
  \begin{matrix}
  X & 0 \le X < 1\\
  1 - X = 1 + |X| & -1 < X \le 0
  \end{matrix}
  \right.
  $$
  $[X]原 = 1 + |X|$ 就相当于——符号位变成 1特点

  ![image-20210422163156394](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121204.png)

- 定点整数的原码
  $$
  [X]原 = 
  \left\{
  \begin{matrix}
  X & 0 \le X < 2^{n-1} \\
  2^{n-1} - X = 2^{n-1} + |X| & -2^{n-1} < X \le 0
  \end{matrix}
  \right.
  $$
  $[X]原 = 2^{n-1} + |X|$ 就相当于——符号位变成 1

  ![image-20210422164349643](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121205.png)

- 表示范围

  n 位原码，包括一位符号位，可表示的数值范围

  纯小数：$[-(1-2^{-(n-1)}), +(1-2^{-(n-1)})]$

  纯整数：$[-(2^{n-1}-1), +(2^{n-1}-1)]$

- 0 的原码表示
  $$
  [+0]原 = 0 \quad 0000000 \\
  [-0]原 = 1 \quad 0000000
  $$

- 真值与原码转换

  符号位：0+互变，1-互变

  数值位：保持不变

  ![image-20210422165237712](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121206.png)

- 特点

  优点：原码表示简单、直观，机器数和真值间的相互转换很容易。用原码实现乘、除运算的规则很简单，可取其绝对值（原码的数值部分）直接运算，并按同号相乘除结果符号为正、异号相乘除结果符号为负的原则，单独处理符号位。
  缺点：机器零不惟一，有＋0 和－0 两种表示方法；实现加、减运算的规则较复杂。比如，若要实现异号数相加，首先要比较两数绝对值的大小，然后再用绝对值大的数减去绝对值小的数，并确定结果的符号位。

- 例题

  ![image-20210422165426171](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121207.png)

- 求法总结

  由真值求原码——

  符号位：0+互变，1-互变

  数值位：保持不变

### 反码

- 简介

  反码一般作为原码和补码转换的中间过渡

- 定点小数的反码
  $$
  [X]反 = 
  \left\{
  \begin{matrix}
  X & 0 \le X < 1 \\
  (2-2^{-(n-1)}) + X & -1 < X \le 0
  \end{matrix}
  \right.
  \quad (mod(2-2^{-(n-1)}))
  $$
  ![image-20210422172557927](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423121208.png)

- 定点整数的反码
  $$
  [X]反 =
  \left\{
  \begin{matrix}
  X & 0 \le X < 2^{n-1} \\
  (2^n-1) + X & -2^{n-1} < X \le 0
  \end{matrix}
  \right.
  \quad (mod(2^n-1))
  $$
  
- 表示范围

  n 位反码，包括一位符号位，可表示的数值范围

  纯小数：$[-(1-2^{-(n-1)}), +(1-2^{-(n-1)})]$

  纯整数：$[-(2^{n-1}-1), +(2^{n-1}-1)]$

- 0 的反码表示
  $$
  [+0]反 = 0 \quad 0000000 \\
  [-0]反 = 1 \quad 1111111
  $$
  
- 原码与反码转换

  正数：相同

  负数：符号位不变，数值位全部取反

- 特点

- 例题

- 求法总结

  原码求反码——

  正数：相同

  负数：符号位不变，数值位全部取反

### 补码

- 简介

  补数：时钟指针指示在 6 点，欲使它指示 3 点，既可顺时针转动，又可逆时针转动，其结果是一致的。由于时钟的时针转一圈能指示 12 个小时，因此时钟指针两个方向转动产生的效果在数学上称为**模 12 运算**，写在 mod 12。

  将补数的概念用到计算机中，便出现了补码机器数

- 定点小数的补码
  $$
  [X]补 = 
  \left\{
  \begin{matrix}
  X & 0 \le X < 1 \\
  2 + X = 2 - |X| & -1 \le X < 0
  \end{matrix}
  \right.
  \quad (mod(2))
  $$
  ![image-20210423123109870](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160755.png)

- 定点整数的补码
  $$
  [X]补 = 
  \left\{
  \begin{matrix}
  X & 0 \le X < 2^{n-1} \\
  2^n + X = 2^n - |X| & -2^{n-1} \le X < 0
  
  \end{matrix}
  \right.
  \quad mod(2^n)
  $$
  ![image-20210423140652511](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160756.png)

- 表示范围

  n 位补码，包括一位符号位，可表示的数值范围

  纯小数：$[-1, +(1-2^{-(n-1)})]$

  纯整数：$[-2^{n-1}, +(2^{n-1}-1)]$

- 0 的补码表示
  $$
  [+0]补 = 0 \quad 0000000 = [-0]补
  $$
  
- 求补运算

  不分数值位和符号位，全部取反，然后加一

  此操作相当于：从后往前找 1，以此 1 为分界，后面的 0 保持不变，前面的位全部取反

- 原码与补码的转换

  正数：相同

  负数：符号位不变，数值位全部取反，然后加一

- 反码与补码的转换

  正数：相同

  负数：反码加一得补码

- 求 $[-X]补$

  $[-X]补 = [[X]补]求补$

  $[X-Y]补 = [X]补 - [Y]补 = [X]补 + [[Y]补]求补$

- 变形补码

  在补码基础上，多加一位二进制位，采用双符号位

  高符号位是真正的符号位，低符号位用来判别“溢出”

- 特点

- 例题

  ![image-20210423142639870](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160757.png)

- 求法总结

  原码求补码——

  正数：相同

  负数：符号位不变，数值位全部取反，然后加一

### 移码

- 简介

  真值用补码表示时，无法从补码的形式上直接判断其真值的大小，故在补码表示的编码基础上再加上一个偏移量（$2^{n-1}$），就构成了新的编码，即移码

- 定点整数的反码
  $$
  [X]移 = 2^{n-1} + X \quad -2^{n-1} \le X < 2^{n-1} \quad mod(2^n)
  $$

- 表示范围

  n 位反码，包括一位符号位，可表示的数值范围

  纯整数：$[-(2^{n-1}-1), +(2^{n-1}-1)]$

- 0 的反码表示
  $$
  [+0]反 = 0 \quad 0000000 \\
  [-0]反 = 1 \quad 1111111
  $$
  
- 补码与移码的转换

  符号位取反，就能相互转换了

- 特点

  移码码值的大小反映了数值的大小，多用于浮点数中表示阶码

- 例题

  ![image-20210423143335908](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160758.png)

### 编码比较

- 真值为正时

  原码、补码、反码的表示形式均相同，即符号位取 0，数值位与真值相同

- 真值为负时

  符号位均取 1，原码的数值位与真值相同，反码的数值位是原码的数值位全部取反，补码的数值位是反码的数值位加一，即是原码的数值位取反加一

  原码的数值位也等于补码的数值位取反加一

- 移码

  移码与补码仅是符号位取反

- 真值范围

  ![image-20210423143702923](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160759.png)

- 雨课堂例题

  ![image-20210424161936905](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115601.png)

## 定点数的运算

- 简介

  运算器用于数值运算及加工处理数据，是由 CPU 中的算术逻辑单元（ALU）、通用寄存器（GR）等部件构成

  运算器的结构取决于指令系统、数据的表示方法、运算方法及所选用的硬件

### 逻辑运算

- 基本逻辑运算：

  + 与 AND

    逻辑与运算也称为逻辑乘运算

    对两个操作数进行按位相与，用符号 ∧ 或 · 表示

    可以对特定的数据位清零，也可以提取特定的数据位

  + 或 OR

    逻辑或运算也称为逻辑加运算

    对两个操作数进行按位相或，用符号 ∨ 或 + 表示

    可以对特定的数据位置 1，也可以保留特定的数据位

  + 异或 XOR

    逻辑异或运算也称为按位加

    是指按位求两个数模 2 相加的和，用符号 $\oplus$ 表示

    两操作数数据位相等则为 0，相反则为 1

  + 非 NOT

    逻辑非运算也称为求反

    对数据位进行取反操作，在变量上方加上横线来表示

    1、0分别转换为 0、1

- 特点：按位操作

- 符号与电路

  ![image-20210424190410316](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115602.png)
  $$
  与：X_i · Y_i \quad \& \\
  或：X_i + Y_i \quad \ge 1 \\
  异或：X_i \oplus Y_i \quad =1 \\
  反相：\overline{X_i} \quad 
  $$
  

### 移位操作

- 基本移位操作

  S-移位 H-逻辑 A-算术 L-左 R-右 C-循环

  SHL-逻辑左移 SHR-逻辑右移 SAL-算术左移 SAR-算术右移

  ROL-不带进位的循环左移 ROR-不带进位的循环右移 RCL-带进位的循环左移 RCR-带进位的循环右移

  ![image-20210424192349429](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115603.png)

  逻辑左移/算术左移：左移进 CF 中，末位补 0

  逻辑右移：右移进 CF 中，高位补 0

  算术右移：右移进 CF 中，高位补符号位

  循环移位：循环着移位

  不带进位的循环左/右移：左/右移进 CF 中

  带进位的循环左/右移：CF 也参与进循环移位中

  ![image-20210427115043187](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115604.png)

- 移位寄存器

- 乘、除 2

  任何编码形式，乘 2 都相当于 逻辑/算术左移一位（符号位不变，末位补 0），除 2 都相当于 算术右移一位（符号位扩展）
  
  看上面的算术移位，好像不能笼统的这样做？

### 定点数加减运算

- 简介

  定点数加减可以用原、反、补、移码运算，因补码运算规则最简单 ，所以最常用

#### 补码加减法

- 补码加法

  运算规则：$[X + Y]补 = [X]补 + [Y]补$

- 补码减法

  运算规则：$[X - Y]补 = [X]补 + [-Y]补 = [X]补 + [[Y]补]求补$

- 例子

  ![image-20210424193438275](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115605.png)

- 补码加减运算规则

  补码加减运算规则：

  1. 参加运算的操作数用补码表示
  2. 符号位参加运算
  3. 若进行相加，则两个数的补码直接相加，若进行相减运算，则将减数连同符号位一起取反加一后，与被减数相加
  4. 运算结果用补码表示

- 加与减

  ![image-20210424193909185](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115606.png)

- 溢出

  ![image-20210424195310201](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115607.png)

- 溢出判定

  + 双符号位判决法

    补码采用两位表示符号，若运算结果两符号分别用 $S_2S_1$ 表示，则判别溢出的逻辑表示式为 $VF = S_2 \oplus S_1$ 

    VF-溢出标志

    00-正 11-负 10/01-溢出

    ![image-20210424195730347](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115608.png)

  + 进位判决法
    $$
    VF = C_{n-1} \oplus C_n \\
    C_{n-1}: 最高数值位产生的进位 \\
    c_n: 符号位产生的进位（即，进位标志 CF）
    $$
    ![image-20210424195758264](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115609.png)

  + 根据运算结果的符号位和进位标志判别
    $$
    VF = SF \oplus CF \\
    SF: 运算结果的符号标志 \\
    CF: 进位标志
    $$
    ![image-20210424195818890](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115610.png)

  + 根据运算前后的符号位进行判别

    ![image-20210424200345545](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115611.png)

#### n 位加减法器

##### 一位全加器

- 简介

  输入：两个运算位—$X_i、Y_i$，低一位对该位的进位—$C_i$

  输出：全加器的结果—$Z_i$，向高一位的进位—$C_{i+1}$

- 逻辑表达式：
  $$
  Z_i = X_i \oplus Y_i \oplus C_i \\
  C_{i+1} = (X_i · Y_i) + (X_i + Y_i) · C_i \\
  = (X_i · Y_i) + (X_i \oplus Y_i) · C_i \\
  C_{i+1} = G_i + P_i · C_i \\
  本位进位函数：G_i = X_i · Y_i \\
  进位传递函数：P_i = X_i + Y_i 或 X_i \oplus Y_i
  $$

- 全加器逻辑

  ![image-20210424203218495](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115612.png)
  
  总的运算时间是三级（三级门）

##### 行波进位

- 电路框图

  又称串行进行加减法器

  ![image-20210424203356719](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115613.png)

  M = 0，Xi + Yi，C0 = 0 —— X + Y

  M = 1，Xi - Yi，C0 = 1——X - Y （取反加一）

- 运算特点

  + 进位逐位产生

    进位是由低到高逐位产生的，故这种加法器称为行波进位（串行进位）加法器，n 位加法运算中，高位运算必须等待低位运算产生进位后方能进行

  + 和逐位生成

    每位和 Zi 的生成时间取决于低位的进位 Ci，所以和的各位也是逐位生成的

  如果一位全加器的延时是 Δt，那么完成 n 位加法需要的时间为 nΔt

- 运算时间

	![image-20210424203833777](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115614.png)

##### 并行进位

- 原理

  在 n 位行波进位加减法器中，串行生成的进位会造成加法速度大为降低，一种有效的改进方式是同时生成所有低位向高位的进位

  仅写出四个进位的产生逻辑表示式

  $$
  即，利用 C_i、X_i...X_k、Y_i...Y_k 直接生成 C_{k+1} \\
  即，利用 C_i、P_i...P_k、G_i...G_k 直接生成 C_{k+1} \\
  G_i = X_iY_i \quad P_i = X_i \oplus Y_i \\
  C_{i+1} = G_i + P_iC_i \\
  C_{i+2} = G_{i+1} + P_{i+1}C_{i+1} = G_{i+1} + P_{i+1}G_i + P_{i+1}P_iC_i \\
  ... \\
  C_{i+4} = G_{i+3} + P_{i+3}G_{i+2} + P_{i+3}P_{i+2}G_{i+1} + P_{i+3}P_{i+2}P_{i+1}G_i + P_{i+3}P_{i+2}P_{i+1}P_{i}C_i \\
  令 G^*_{i+3} = G_{i+3} + P_{i+3}G_{i+2} + P_{i+3}P_{i+2}G_{i+1} + P_{i+3}P_{i+2}P_{i+1}G_i \\
  P^*_{i+3} = P_{i+3}P_{i+2}P_{i+1}P_{i} \\
  则 C_{i+4} = G^*_{i+3} + P^*_{i+3}C_i
  $$

  将这些先行形成的进位信号并行地加到加法器上，则加法器就不必等待进位产生，从而大大地提高了加法器的速度。也就是说在进行加法运算之前，各位加法器所需要的进位已经产生出来。这将加快加法运算的速度，这就是先行进位的来由

  并（先）行进位加法器——CLA

- 电路框图

  ![image-20210424210026486](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115615.png)

- 运算特点

  输入信号经过三级门便可以得到所有四位加法器所需要的所有进位信号，三级门的延时要比多级行波进位加法器的延时小得多

  如果一位全加器的延时是 Δt，先行进位产生电路的延时是 τ，那么最低位生成需要 Δt，其余位生成需要 Δt+τ，完成 n 位加法需要的时间为 Δt+τ

- 运算时间

  ![image-20210424211110220](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115616.png)

##### 组内并行、组件串行

组内并行、组间串行进位又称为单级先行进位

- 原理

  随着位数 n 的增大，先行进位产生电路会越来越复杂，因此，在设计加法器时会将多位加法器分组

  以 16 位加法器为例，将其分为 4 组，每组 4 位，各组内采用 4 位并行进位加法器，组间采用行波进位方式，这样就构成了组内并行、组间串行进位的加法器

- 电路框图

  ![image-20210424212317150](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115617.png)

- 运算特点

  组间进位是串行的，即每个组的进位输入是相邻低位组的进位输出，而每个组的进位输出是相邻高位组的进位输入。串行进位链的总延迟时间与分组数目成正比

  若 4 位 CLA 的延时为 Δt'(=Δt+τ)，则 16 位并行加法器的计算时间就是 4Δt'，若 n 位加法器分为 m 组，则加法器的计算时间就是 mΔt'

- 运算时间

  ![image-20210424213236856](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115618.png)

##### 组内并行、组间并行

组内并行、组间并行进位又称为多级先行进位

- 原理

  ![image-20210424213601419](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115619.png)

- 电路框图

  ![image-20210424214604084](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115620.png)

- 运算时间

  ![image-20210424215036332](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115621.png)

#### BCD数加法器

- BCD 数

  ![image-20210424215407715](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115622.png)

- 8421 BCD 码

  ![image-20210424220021166](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115623.png)

- 电路框图

  ![image-20210424221018785](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115624.png)

  合法字符

  0000-0111、1000、1001

  非法字符 A-1010、B-1011、C-1100、D-1101、E-1110、F-1111

  第 4 位为 1，第 2/3 位为 1，则非法

  校正则加 6H-0110

#### 移码加减法

- 原理与例题

  ![image-20210424222027673](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115625.png)

- 电路框图

  ![image-20210424221851134](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115626.png)

### 定点数乘法

#### 原码乘法

##### 原码一位乘

- 手工乘法运算

  ![image-20210425221305752](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115627.png)

  [Z]原 = [X * Y]原 = 1.10001111

- 原码一位乘规则

  假定被乘数 X 和乘数 Y 为用原码表示的纯小数，分别为：
  $$
  [X]原 ＝ X_0 . X_{-1} X_{-2} ... X_{-(n-1)} \\
  [Y]原 ＝ Y_0 . Y_{-1} Y_{-2} ... Y_{-(n-1)} \\
  $$
  其中 $X_0、Y_0$ 是它们的符号位。同时，假定乘积为：$[Z]原 = Z_0. Z_{-1} Z_{-2} ... Z_{-(2n-1)}$

  乘法法则：

  1. 乘积的符号为被乘数的符号位与乘数的符号位相异或
  2. 乘积的绝对值为被乘数的绝对值与乘数的绝对值之积
  3. 乘积的原码为：$[Z]原 = [X * Y]原 = (x_0 \oplus y_0)(|X| * |Y|)$

  即，被乘数 X 与乘数的某一位 $2^iy_i$ 相乘得到部分和 $2^iy_iX$，所有部分和加在一起得到乘积的数值

  手算过程中，根据乘数各位权值不同，部分和 $y_iX$ 需要左移 i 位加到部分积上，在实际构成乘法器时，这样做会要求运算位长不断增加，造成乘法器设计复杂度和成本提高。如果将各部分和的累加过程加以改变，即将累加生成的部分积右移，新获得的部分和以不移动的方式加入已右移的部分积中，完成部分积累加，则会使硬件实现更容易

- 思路框图

  共 n 位，1 位符号位，n-1 位数值位

  ![image-20210425232915221](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115628.png)

- 乘法器运算

  ![image-20210425233024025](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115629.png)

- 原码一位乘法器电路框图

  ![image-20210425233105301](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115630.png)
  
  初始：D-全0 A-乘数 B-被乘数 XY-被乘数*乘数-BA B-X A-Y
  
  最终：DA-乘积结果

##### 阵列乘法器

- 简介

  在上述乘法运算中，是利用简单的硬件进行多次加法和多次移位来实现乘法的，为了提高运算速度，可以采取类似人工手算的方法

- 运算原理

  ![image-20210426210056469](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115631.png)

- 电路框图

  ![image-20210426210222646](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115632.png)

  XiYj 是与运算，而 Zi 是对相应列中各个与结果的求和

#### 补码乘法 

##### 补码一位乘-校正法

- 简介

  ![image-20210426210547831](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115633.png)

##### 补码一位乘-布斯法

- 简介

  ![image-20210426210701581](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115634.png)

- 乘数相邻两位的操作规律

  ![image-20210426210742863](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115635.png)

- 运算法则
  1. 乘数与被乘数均用补码表示，连同符号位一起参加运算
  2. 乘数最低位后增加一个附加位（可用 $A_{-1}$ 表示）初始设定为 0
  3. 从附加位开始，依据上表所示的操作规律，完成运算

- 思路框图

  ![image-20210426211100619](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115636.png)

- 运算举例

  ![image-20210426211307285](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115637.png)

  小数运算，小数点后只有 8 位，故最后要左移一位

  整数运算，小数点就在 符号-D 的位置，故不需要移位操作

  A-存储补码表示(Y-5 位)，X-双符号位表示，防止溢出

- 电路框图

  ![image-20210426212002532](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115638.png)

##### 阵列乘法器

- 简介

  在无符号数阵列乘法器的基础上，很容易实现补码阵列乘法器

  基本思路是：先求被乘数与乘数的绝对值（无符号数），然后进行无符号数阵列乘法，最后根据被乘数与乘数的符号决定最终乘积的符号

- 求补电路

  ![image-20210426212626686](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115639.png)

  只要将有符号数的符号位加到控制端 E 上，即可求得该符号数的绝对值

  E = 0，与的结果为 0，经过异或门， ai 与 0 异或，原样输出

  E = 1，a0 原样输出，

  ai = 0，或门输出 0，

  遇到 ai = 1，或门则输出 1，与门输出 1，aj(j>i) 与 1 异或，输出相反值

- 电路框图

  ![image-20210426213444142](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115640.png)

### 定点数除法

#### 原码除法

- 手工除法过程

  ![image-20210427085701610](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115641.png)
  
- 原码除法法则

  ![image-20210426213741179](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115642.png)
  
  运算输入和运算输出的数的类型要保持一致，故做小数运算时，要求结果也为小数，做整数运算时，要求结果也为整数

##### 恢复余数法

- 简介

  ![image-20210427090727413](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115643.png)

- 恢复余数法

  ![image-20210427090825421](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115644.png)

- 定点纯小数数值部分计算的流程框图

  ![image-20210427090921943](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115645.png)

- 运算示例

  被除数长度是除数长度的两倍，若长度不够，则需要进行扩展，末尾补 0

  DA 会算术左移，故在被除数前面预留两位符号位（使用的是绝对值|X|，故初始为 00），且需要判断正负，来决定商 0/1

  -|Y| 相当于 +[|Y|]求补

  ![image-20210427094855917](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115646.png)

##### 加减交替法

- 简介

  恢复余数法在运算位数相同的情况下，不同的被除数和除数在运算中何时需恢复余数不相同，运算时间不一致，实现起来不便于控制。因此，恢复余数法在计算机中并不常用，而是使用加减交替法

- 加减交替法

  ![image-20210427095539926](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115647.png)

- 运算示例

  ![image-20210427095754651](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115648.png)

- 电路框图

  ![image-20210427095816029](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115649.png)

  够减商1-DS=0 A0=1

  不够减商0-DS=1 A0=0

  D-余数 A-商 DS-判断是否够减-进行商

- 例题

  ![image-20210427103411381](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115650.png)

  异或电路：原码除法（加减交替法），可能+|Y|，也可能-|Y|，这也是 Zs 控制的，Zs=0，则 R >= 0，够减，商 1，-|Y|，取反加一，与 1 异或，Zs=1，则 R < 0，不够减，商 0，+|Y|，与 0 异或

  （与 0 异或，原样输出；与 1 异或，反相输出）

##### 阵列除法器

![image-20210427100806760](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115651.png)

略

#### 补码除法

##### 加减交替法

- 加减交替法

  ![image-20210427102223782](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115652.png)

- 思路框图

  ![image-20210427102257650](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115653.png)

- 运算示例

  ![image-20210427103030547](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115654.png)

- 电路框图

  ![image-20210427103241226](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427115655.png)