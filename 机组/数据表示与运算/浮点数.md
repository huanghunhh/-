# 浮点数

- 简介

  定点数的表示范围有限，为表示很大的数值范围，必须用浮点数表示。其小数点位置不固定。

## 编码格式

- 浮点数的编码

  浮点数**真值** N
  $$
  N = (-1)^{M_S} * M * B^E \\
  B - 阶码的底，即尾数 M 的基值，一般为 2（隐含约定，不需要存储） \\
  E - 阶码 \\
  M - 尾数 \\
  M_S - 尾数的符号位
  $$
  

  阶码 E 是整数，决定了浮点数表示的数值范围，常用移码表示

  尾数 M 是小数，决定了浮点数的精度，常用补码或源码表示

- 浮点数的存储格式

  ![image-20210423144650843](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160812.png)

  | 数符  | 阶码  | 小数点 | 尾数的数值部分 |
  | ----- | ----- | ------ | -------------- |
  | 1 bit | k bit | 无     | (n-1) bit      |

- 非规格化浮点数

  当对尾数 M 只要求是小数而无其他限制时，此时的浮点数被称为非规格化浮点数

  ![image-20210423151657283](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160813.png)

## 规格化浮点数

- 简介

  将尾数的绝对值限定在规定的数值范围内，即 $1/2 \le |M| \le 1$。规格化浮点数是 M 有效数的最高有效位为非零的数

- 规格化形式

  + 原码
    $$
    [M]原 = 0 \quad 1 \quad xxx... \\
    [M]原 = 1 \quad 1 \quad xxx... \\
    $$
    第一个位是符号位，第二个位是最高有效位，必须为非零的数

  + 补码
    $$
    [M]补 = 0 \quad 1 \quad xxx... \in [+1/2, +(1-2^{-n})]\\
    [M]补 = 1 \quad 0 \quad xxx... \in [-1, -(1/2+2^{-n})]\\
    $$
    第一个位是符号位，第二个位是最高有效位，根据原码转换过来

- 表示范围

  ![image-20210423153405224](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160814.png)

- 溢出

  ![image-20210423153146790](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160815.png)

- 规格化操作

  ![image-20210423153237554](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160816.png)

- 例题

  ![image-20210423153304305](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160817.png)

## IEEE 754 标准

- 简介

  IEEE 754 标准规定了单精度和双精度两种基本的浮点格式以及双精度扩展等多种浮点格式。

  规定了浮点数的尾数用原码表示，对于用原码表示的规格化的二进制浮点数，尾数有效位的第一位一定是 1，而不是 0，则在存储时，将这个默认的 1 省去，从而使得有效位又增加了一位

  故真值的格式为 $\pm 1.f$

  ![image-20210423154034114](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160818.png)

- 编码

  单/双精度浮点数的**真值** N
  $$
  N = (-1)^S * 2^{e-偏移值} *1.f \\
  s - 数符（1 bit） \\
  f - 尾数（23/52 bit） \\
  e - 阶码（8/11 bit） \\
  偏移值 - 127/1023
  $$
  ![image-20210423154553954](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160819.png)

- 范围

  e = 0 或 (255/2047) 时，表示特殊的数

  单精度： $e-127 \in [-126, +127] \quad e \in [+1, +254]$

  双精度： $e-1023 \in [-1022, +1023] \quad e \in [+1, +2046]$

  ![image-20210423154859566](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160820.png)

- 例题

  ![image-20210423155313526](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160821.png)

- 溢出

  ![image-20210423155444597](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160822.png)

- 舍入模式

  ![image-20210423155514975](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210423160823.png)

- 雨课堂例题

  ![image-20210427104125768](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152322.png)

## 浮点数的运算

- 简介

  X、Y 为规格化浮点数

  格式为：$X = M_x * 2^{E_X} \quad Y = M_y * 2^{E_y}$
  
  M - 尾数：小数
  
  E - 阶码：整数

### 浮点数加减法

#### 计算步骤

- 对阶

  对阶就是小数点对齐，只有当两者的阶码相同时，才能进行加减运算

  对阶的原则是小阶对大阶，即小阶码每增加 1，其尾数右移一位，直到增大到与大阶码相同（这样对阶，丢失的是尾数的低位，造成的误差很小。若是大阶对小阶，将丢失尾数的高位，从而导致错误的结果）

- 尾数加减运算

  对阶之后，尾数进行加（减）运算，减法可以用加法实现

- 规格化

  如果结果是非规格化数（即，尾数的真值 M 不满足 1/2 ≤ |M| < 1），则需要规格化

  + 左规

    如果运算结果尾数为双符号补码 11.1XX…X 或者是 00.0XX…X（尾数未溢出）时，规格化需将尾数左移 。每左移一位，阶码减 1，直到使尾数成为规格化数为止。
    阶码减 1 时，需判断是否下溢，若阶码（包括 1 位符号位）用 m 位移码整数表示，则它能表示的最小阶码位 $-2^{m-1}$，如果左规使阶码小于 $-2^{m-1}$，则发生下溢出 。若发生下溢出，则认为结果为0

  + 右规

    若尾数加/减时，结果（尾数）发生溢出，即出现 10.XX…X 或者 01.XX…X 时，表明尾数有溢出，整个浮点数结果未必溢出。
    可将尾数右移一位，阶码加 1，即右规。右规最多 1 次。
    阶码加 1 时，需判断是否上溢，如大于 $2^{m-1}-1$，则发生上溢出。若发生上溢出，认为结果为 ∞

  可见，浮点数的溢出与否只由阶码决定

- 舍入处理

  在对阶及规格化时需要将尾数右移，右移将丢掉尾数的最低位，这就出现舍入的问题。

  + 截（尾）断法
    此法最简单，就是将需丢弃的尾数低位丢弃。

  + 末位恒置 1 法
    无论尾数右移丢弃的是 0 还是 1，此法将保证要保留的尾数的最低位永远为 1。

  + 0 舍 1 入法
    当尾数右移丢弃的是 1 时，要保留的最末位加 1；
    当尾数右移丢弃的是 0 时，要保留的最末位不变

#### 流程框图

![image-20210427121537070](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152323.png)

![image-20210427121558672](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152324.png)

#### 计算示例

![image-20210427121951173](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152325.png)

### 浮点数乘法

- 两浮点数相乘
  $$
  X = M_x * 2^{E_x} \quad Y = M_y * 2^{E_y} \\
  则，其乘积：Z = (M_x * M_Y) 2^{E_x + E_y}
  $$
  即，乘积的阶码为两乘数阶码之和，乘积的尾数为两乘数尾数之积

- 浮点乘法运算过程

  1. 参与运算的两浮点数一定是规格化数，且不为 0，若有一个乘数为 0，则乘积必为 0

  2. 求乘积的阶码，即 $E_z = E_x + E_y$，判断积的阶码是否溢出

     当 $Ez > E_{max}$ 时，上溢，乘积将无法表示

     当 $Ez < E_{min}$ 时，下溢，乘积可用 0 表示

     当发生溢出时，尤其是上溢，应重新定义浮点数或对两乘数作出限制

  3. 两乘数的尾数相乘

     参照定点数相乘

  4. 规格化乘积的尾数

     即规格化浮点数—— n 位补码表示，正数范围 $[+1/2, +(1-2^{-(n-1)})]$，负数范围 $[-1, -(1/2 + 2^{-(n-1)})]$

     因为，两乘数的尾数均为规格化数，则两者之积的绝对值肯定不小于 1/4，因此左规的最大次数为 1 次，且，两者之积最大也只能为 +1，因此右规的最大次数也为 1 次

- 计算流程框图

  ![image-20210427141253660](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152326.png)

### 浮点数除法

- 两浮点数相除
  $$
  X = M_x * 2^{E_x} \quad Y = M_y * 2^{E_y} \\
  则，其相除：Z = (M_x ÷ M_Y) 2^{E_x - E_y}
  $$
  即，两浮点数相除的结果的阶码为被除数的阶码减去除数的阶码，商的尾数为被除数的尾数除以除数的尾数

- 浮点数除法运算步骤

  1. 若被除数为 0，则商为 0；若除数为 0，则作为错误处理

  2. 求商的阶码，即 $Ez = Ex - Ey$，判断商的阶码是否溢出

     当 $Ez > E_{max}$ 时，上溢，商将无法表示

     当 $Ez < E_{min}$ 时，下溢，商可用 0 表示

     当发生溢出时，尤其是上溢，应重新定义浮点数或对被除数、除数作出限制

  3. 被除数的尾数除以除数的尾数

     可以选择定点小数除法中的任何一种方法，浮点除法中，不再单独要求 |被除数| < |除数|

  4. 规格化商的尾数

     左规和右规的最大次数也为 1 次

- 计算流程框图

  ![image-20210427142717478](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152327.png)

  ![image-20210427142739500](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152328.png)

## 浮动运算的实现

![image-20210427142849258](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152329.png)

## 运算器基本结构

### ALU

![image-20210427150643836](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152330.png)

### 运算器

- 简介

  ALU 与通用寄存器、暂存器、状态寄存器等部件以某种连接方式进行有效互连就构成了处理器中的重要部件——运算器

#### 三种基本结构

![image-20210427151052899](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152331.png)

- 单总线结构

  同一时间内，只能有一个操作数放在总线上进行传输

  当执行双操作数运算指令时，需要分两次才能将两个操作数输入 ALU，并且需要两个暂存器，即，需要三步操作控制（对应三个时钟节拍）方可得到运算结果

- 双总线结构

  可以同时传输两个数据

  当执行双操作数运算指令时，两个操作数可以同时加载到 ALU 进行运算

  此时两条总线被两个操作数占用，运算结果需要在 ALU 输出端设置暂存器来存储运算结果，在下一个时钟节拍才能将运算结果写入目的寄存器。

  即，需要两步操作控制（两个时钟节拍）才可以得到运算结果

- 三总线结构

  运算的相关部件连接到三条总线上，可以同时传输三个数据

  当执行双操作数运算指令时，两个操作数可以同时加载到 ALU 进行运算，第三条总线输出运算结果，只需要一步操作控制（一个时钟节拍）就可以完成运算

  此外，三总线结构运算器还具有直接传送功能，一个不需要修改的操作数可以通过总线开关从输入总线直接传送到输出总线

#### 运算器实例

![image-20210427151338409](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/%E6%9C%BA%E7%BB%84/20210427152332.png)

8086 微机系统简化框图