# 排序算法

## 概念

### 排序

### 稳定性

### 分类

#### 内部排序

- 插入排序

  将无序子序列中的一个或几个记录`插入`到有序序列中，从而增加记录的有序子序列的长度。

- 交换排序

  通过`交换`无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。

- 选择排序

  从记录的无序子序列中`选择`关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。

- 归并排序

  通过`归并`两个或两个以上的有序子序列，逐步增加记录有序序列的长度。

- 分配排序

#### 外部排序

- 多路平衡归并排序
- 置换 - 选择排序
- 最佳归并树

### 排序的度量

- 比较记录的关键字
- 移动记录

## 插入排序

### 直接插入排序

- tzy

  分为两部分：有序序列 无序序列

  初始时，有序序列仅包含第一个元素

  每次从无序序列中取出第一个元素，将其插入到有序序列中的适当位置

- 过程示例

  ![直接插入排序](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206201659.png)

- 算法

- 性能

  + 时间复杂度

    * 最好情况 

      移动 0 

      比较 $n-1$

    * 最坏情况

      移动 $(n+4)(n-1)/2$

      比较 $(n+2)(n-1)/2$ 
    
      ==需要和监视哨比较一下==

  + 空间复杂度

    O(1)

  + 稳定

  + 适用情况
  
    元素数目少，或元素的初始序列基本有序





### 折半插入排序

​	插入时，采用二分查找

### 2-路插入排序

### 表插入排序

​	按关键码的大小，实现从小到大的链接过程，排序过程中不移动元素，用静态链表实现

### 希尔排序

- 算法思想

  先将整个待排序元素序列分割成若干个小的子序列（等间距的元素分在同一个子序列），在小序列内进行直接插入排序；
  （缩小间距）增加子序列的长度（序列个数减少），再对每个子序列进行直接插入排序
  在整个序列基本有序情况下，最后再对全体元素进行一次直接插入排序。

- 过程示例

	![希尔排序过程示例](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206201719.png)

- 算法

- 性能

  + 不稳定
  
    

## 交换排序

### 冒泡排序

- tzy

  相邻位置的关键字进行比较，大的就往后，一趟把一个值冒泡到位（一次一个泡泡冒到位）

  若在一趟排序过程中没有进行过交换，则整个排序过程终止

- 过程示例

  ![冒泡排序过程示例](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206201725.png)

- 算法

- 性能

  + 时间复杂度

    * 最好情况

      比较 $n-1$

      移动 0

    * 最坏情况

      比较 $n(n-1)/2$

      交换 $n(n-1)/2$

  + 空间复杂度

    O(1)

  + 稳定

  + 适用情况

    元素数目少，或者元素的初始序列基本有序

### 快速排序

- 概念

  基准（枢轴）- 取序列中的某个元素作为基准（一般取第一个元素）

  划分 - 通过一趟排序，将待排序列划分为左右两个子序列，使左子序列元素的关键字均不大于基准元素，右子序列的关键字均不小于基准元素

- tzy

  小的去左边，大的去右边，乖乖排顺序，快速的确快

  枢轴为基准，另边做比较，满足就放过，继续下一个

  不满就交换，换边继续来，左右荡一荡，枢轴定本位

- 过程示例

  ![快速排序中的一趟划分](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206201732.png)

  ![快速排序过程示例](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206201740.png)

- 算法

- 性能

  + 时间复杂度

    O($nlogn$)

    最坏情况 O($ n^2 $)
  
  + 空间复杂度
  
    O($logn$)
  
  + 不稳定
  
  + 适用情况
  
    不适合对小规模的序列进行排序

- 改进

  枢轴元素的选取

  划分的过程中进行冒泡操作

  但划分出的子序列长度小于某个值时，不再递归，而进行直接插入排序

- 评价

  内部排序方法中最好的一种

## 选择排序

### 简单选择排序

- 算法思想

  第 $i$ 趟在 $n-i+1$ 个记录中选取最小的记录作为有序序列多中的第 $i$ 个记录。

- tzy

  找出来

- 过程示例

  ![简单选择排序过程示例](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201206204458.png)

- 算法

- 性能

  + 时间复杂度

    * 最好情况

      比较 $n(n-1)/2$

      移动 $0$

    * 最坏情况

      比较 $n(n-1)/2$

      移动 $3(n-1)/2$

  + 空间复杂度

    O(1)

  + 不稳定

  + 适用情况

    元素数目少

    无需完全排序，可以直接选出第 i 小的元素

### 树形选择排序

- 又称 锦标赛排序

- 算法思想

  对n个记录的关键字进行两两比较，选出较小着

  重复选择，直至选出最小关键字的记录

  选出最小记录后，将树中的该最小记录修改为 $\infty$ ，然后从该叶子结点所在子树开始，修改到达树根的路径上的结点

  以后每选出一个小元素，都只需进行 $logn$ 次比较

- 应该不重要吧

### 堆排序

- 堆

  + 堆

    完全二叉树

    对于 $n$ 个元素的序列 ${k_1, k_2, ... , k_n}$ ，当且仅当满足以下关系时，称之为堆。

  $$
  大顶堆 
  \begin{cases}
  	k_i \ge k_{2i}\\
  	k_i \ge k_{2i+1}
  \end{cases}
  或 \quad
  小顶堆
  \begin{cases}
  	k_i \le k_{2i}\\
  	k_i \le k_{2i+1}
  \end{cases}
  $$

  + 大顶堆 max heap
  + 小顶堆 min heap

- 堆排序

  1. 建堆

     对一组待排序记录的关键字，首先把它们按堆的定义建成初始小(大)顶堆

  2. 输出并调整

     然后输出堆顶的最小(大)关键字所代表的记录，再对剩余的关键字建堆，以便得到次小(大)的关键字

  3. 反复

     如此反复进行，直到全部关键字排成有序序列为止。


- 输出并调整

  + 输出堆顶元素

    将堆顶元素与序列末端元素交换，需要排序的其余元素序列构成完全二叉树。 

    ![输出堆顶元素](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207093013.png)

  + 调整为堆

    从树根开始，若以某结点为根的子树不是堆，则将其孩子中的较小者与之交换，即将非堆的子树推向叶子方向

    ==将孩子中的较小（大）者与父结点相比较==

    ![调整为堆1](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207094209.png)
    
    ![调整为堆2](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207094307.png)
    
    输出堆顶元素
    
    ![输出堆顶元素](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207094519.png)
  
- 建堆

  + 构造出完全二叉树再去调整

    从最后一个具有孩子的结点(编号 $[n/2]$ )开始建子堆，依次考查结点 $[n/2]-1, [n/2]-2, ..., 1$等是否为堆，若否则调整为堆

    ![建堆1](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207095204.png)

    ![建堆2](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207095250.png)

    ![建堆3](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20210417195642.png)

  + 从空堆开始建堆

- 堆排序复习

  1. 建初始堆（大顶堆）

     将初始序列用一棵完全二叉树表示，然后从最后一个具有孩子的结点开始调整，直到根结点为止

  2. 大顶堆建好后，将堆顶元素与序列末端元素交换，然后对除了序列末端元素外的剩余元素再调整成大顶堆，以便选出次大元素，余类推
  3. 调整到只剩一个元素需要建堆时为止，此时得到有序序列

- 算法

- 性能

  + 时间复杂度 $O(nlog_2n)$

  + 空间复杂度 $O(1)$

  + 不稳定

  + 适用情况

    数量大的序列



## 归并排序

- 归并

  将两个或两个以上的有序序列合并成为一个新的有序序列。利用归并的思想可以进行排序。

- 两路归并排序算法思想
  1. 将由 $n$ 个记录的一个无序序列看成是由 $n$ 个长度为 $1$ 的有序子序列组成的序列
  2. 进行两两归并，得到 $[n/2]$ 个长度为 $2$ 或 $1$ 的有序子序列，再两两归并
  3. 如此重复，直到最后形成包含n个记录的一个有序序列为止。

- 过程示例

  ![两路归并过程示例](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207105438.png)

  ![两路归并排序先分解再归并](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207105530.png)

- 算法

- 性能

  + 时间复杂度 $O(nlogn)$

  + 空间复杂度 $O(n)$
  + 稳定

## 基数排序

- 多关键字排序

  + 概念

    $n$ 个元素的序列 ${R_1, R_2, ..., R_n}$ ，每个元素 $R_i$有 $d$ 个关键字 $(K^0_i, K^1_i, ..., K^{d-1}_i)$ ，则序列对关键字 $(K^0_i,  K^1_i, ..., K^{d-1}_i)$ 有序是指：对于序列中任意两个记录 $R_i$ 和 $R_j$ 记都满足下列有序关系：
       $(K^0_i, K^1_i, ..., K^{d-1}_i) < (K^0_j, K^1_j, ..., K^{d-1}_j)
    $ 

     其中 $K^0$ 称为最主位关键字， $K^{d-1}$ 称为最次位关键字。

  + 最高位优先（MSD）

    1. 先对最主位关键字 $K^0$ 进行排序，将序列分成若干个子序列，每个子序列中的元素具有相同的 $K^0$ 值

    2. 然后分别就每个子序列对关键字 $K^1$ 进行排序，按 $K^1$ 值的不同再分成更小的子序列
    3. 依次重复，直至对 $K^{d-2}$ 进行排序之后得到的每个子序列中的元素都具有相同的 $(K^0, K^1, ..., K^{d-2})$ 
    4. 而后分别对每个子序列对 $K^{d-1}$ 进行排序，最后将所有子序列依次联接在一起成为一个有序序列。

  + 最低位优先（LSD）
    1. 先对最次位关键字 $K^{d-1}$ 进行排序
    2. 然后对 $K^{d-2}$ 进行排序
    3. 依次重复，直至对 $K^0$ 进行排序后便形成一个有序序列。

- 基数排序算法思想

  + 多关键字排序

    借助多关键字排序的思想，对单逻辑关键字进行排序，不需要进行记录关键字间的比较。

  + 分配

    第一次按最低位关键字(个位数)进行分配，将初始序列中的元素分配到RADIX个队列中去，每个队列中的元素的关键字的个位数相同。

    下一次按次低位关键字分配，用 $f[i]$ 和 $e[i]$ 分别表示第 $i$ 个队列的头指针和尾指针。

  + 收集

- 例子

  扑克牌的整理

  图书馆卡片的排序

- 过程示例

  ![链式基数排序过程示例1](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207111842.png)

  ![链式基数排序过程示例2](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207111859.png)

  ![链式基数排序过程示例3](https://gitee.com/twilight_h_1184651848/pic-go-img/raw/master/datastructure/sortAlgorithm/20201207111915.png)

  + 分析（想队头是最小/最大）

  + 需要注意分配、收集的顺序（还没理清）

  + 从小到大输出

    从低位开始分配，从小的开始收集

  + 从大到小输出

    从高位开始分配，从大的开始收集

- 性能

  + 时间复杂度

    $O(d(n+rd))$

    每一趟分配 $O(n)$

    每一趟收集 $O(rd)$

    共 $d$ 趟 $d(n+rd)$

  + 空间复杂度

    $O(rd)$

    $2rd$ 个队列指针

  + 稳定

  + 适用情况

    元素数目 $n$ 很大，且关键字很小

## 内部排序方法分析与比较

|排序|平均时间复杂度|最好时间复杂度|最坏时间复杂度|空间复杂度|稳定性|适用情况|
| :---: | : --- : | : ---: | : ---: | : --- : | - --- - | - --- - |
|直接插入排序| $O(n^2)$     | $O(n)$ | $O(n^2)$ |$O(1)$ | 稳定 | $n$ 较小，初始序列基本有序|
|希尔排序| $O(n^{1.3})$ |  |  |$O(1)$ | 不稳定 | |
|冒泡排序| $O(n^2)$ | $O(n)$ | $O(n^2)$ |$O(1)$ | 稳定 | $n$ 较小，初始序列基本有序 |
|快速排序| $O(nlog_2n)$ | $O(nlog_2n)$ | $O(n^2)$ |$O(log_2n)$ | 不稳定 | 初始序列无序 |
|简单选择排序| $O（n^2）$ | $O(n^2)$ | $O(n^2)$ |$O(1)$ | 不稳定 | $n$ 较小 |
|堆排序| $O(nlog_2n)$ |$O(nlog_2n)$  | $O(nlog_2n)$ |$O(1)$ | 不稳定 | $n$ 较大，或只排前几位 |
|2-路归并排序| $O(nlog_2n)$ | $O(nlog_2n)$ | $O(nlog_2n)$ |$O(n)$ | 稳定 | $n$ 很大 |
|链式基数排序| $O(d(n+rd))$ | $O(d(n+rd))$ | $O(d(n+rd))$ |$O(rd)$ | 稳定 | $n$ 大，关键字值小 |

## 其他的注意点

选前几个大的元素：选用算法-堆排序

基本有序时：选用算法-直接插入排序

元素已经递增：选用算法：冒泡排序，最费时间：快速排序

最坏情况：不选用快速排序

时间复杂度与初始排序无关的算法：简单选择排序


