/*
leetcode 300. 最长递增子序列
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。

示例 1：
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：
输入：nums = [0,1,0,3,2,3]
输出：4

示例 3：
输入：nums = [7,7,7,7,7,7,7]
输出：1 

提示：
1 <= nums.length <= 2500
-104 <= nums[i] <= 104

进阶：
你可以设计时间复杂度为 O(n2) 的解决方案吗？
你能将算法的时间复杂度降低到 O(n log(n)) 吗？

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
*/

/**
 * @param {number[]} nums
 * @return {number}
 */
// 动态规划
var lengthOfLIS = function(nums) {
  // f(i) - nums[0~i] 中的最长递增子序列的长度
  // 状态转移 - f(i) 可由 f(0) f(1) ... f(i-1) 转移过来
  // 需要 max(i) 作为辅助记录 f(i) 中最长递增子序列的最大值
  // f(i) = max(f(0)+(nums>max(0)), f(k)+(nums>max(k)))
  // 这种思路还是有问题—— max(i) 记录有误 [4,10,4,3,8,9] max(2)?

  // 增强条件
  // f(i) - nums[0~i] 中包含 nums[i] 的最长递增子序列的长度
  // 状态转移 - f(i) 可由 f(0) f(1) ... f(i-1) 转移过来
  const n = nums.length
  if (n === 0) {
    return 0
  }
  const f = new Array(n).fill(1) // 初始长度为 1
  let res = 1 // 最终结果
  for (let i = 1; i < n; i++) {
    for (let k = 0; k < i; k++) {
      if (nums[i] > nums[k]) {
        f[i] = Math.max(f[i], f[k] + 1)
      }
    }
    res = Math.max(res, f[i])
  }
  return res
}

// 动态规划 - 算法优化
// 从最长递增子序列的长度出发
// [10,9,2,5,3,7,101,18] 序列中，长度为 1 的最长递增子序列 10, 9, 2 ... 
// 10、9就不需要记录，最长递增子序列的长度增加时，能接在 10、9 后面，就能接在 2 后面
// p(i) - 最长递增子序列的长度为 i 时，子序列结尾的最小值
//（如：长度为 2 的最长递增子序列的序列结尾有 5、3 ...，则记录下 3）
// p(i) 最后的长度，就是数组最长递增子序列的长度（p 是作为维护辅助数组的，和以前的不同，用 p 代替 f）
// 此时 p() 严格单调递增
// 状态转移 - 
// 对 nums() 每次新进来一个数，动态维护 p()
// 对 nums(i)，在 p() 中找到最大的比其小的数，然后更新 p()
var lengthOfLIS = function(nums) {
  const n = nums.length
  if (n === 0) {
    return 0
  }
  const q = []
  let len = 0
  q[0] = -Number.MAX_VALUE // 哨兵
  for (let i = 0; i < n; i++) { // nums() 中，新进来一个数，就动态维护 p()
    // 在 q（递增） 中查找 —— 二分查找
    let l = 0, r = len
    // 在 q[] 中找到最大的比 nums[i] 小的数
    // 此数右边的数，均不比 nums[i] 小
    // 此数左边的数，均比 nums[i] 小
    while (l < r) {
      let mid = l + r + 1 >> 1
      if (nums[i] > q[mid]) {
        l = mid
      } else { // nums[i] <= q[mid]  
        // mid 不可能是结果 -> mid - 1
        r = mid - 1 
      }
    }
    // q(r) 就是最大的比 nums(i) 小的数，然后替换 q(r+1)
    // 要么更新之前的(最长递增子序列的长度为 3，r+1 < 3)
    // 要么新增(最长递增子序列的长度为 3，r+1 = 4)
    len = Math.max(len, r + 1)
    q[r + 1] = nums[i]
  }
  // len === q.lenght - 1(去除 q[0] 这个哨兵)
  return len
}
// 或者叫贪心？
// 如果我们要使上升子序列尽可能的长，则我们需要让序列上升得尽可能慢，
// 因此我们希望每次在上升子序列最后加上的那个数尽可能的小。
// p() 只是作为辅助数组？
// 总结：
// 1. 思路：维护一个数组 p()，记录最长递增子序列的长度为 i 时，子序列结尾的最小值（严格递增的数组）
// 2. 流动：新加进来 nums() 时，动态维护 p()（二分查找），
//  要么更新（递增子序列有更好的），要么新增（最长递增子序列长度+1）
// 3. 结果：p() 的长度就是数组的最长递增子序列的长度
// 前后理顺几遍花了几小时，这样下次遇见应该就会了（哭）

// var nums = [10,9,2,5,3,7,101,18] // 4
// nums = [0,1,0,3,2,3] // 4
// nums = [7,7,7,7,7,7,7] // 1
nums = [4,10,4,3,8,9] // 3
const res = lengthOfLIS(nums)
console.log(res)
